(ns flexiana.scrambler
  (:gen-class)
  (:use [clojure.string :only [replace-first]]
        [compojure.core :refer :all]
        [compojure.handler :as handler]
        [compojure.route :as route]
        [ring.adapter.jetty :only [run-jetty]]
        [clojure.data.json :as json]))

(defn replacer
  "Recursively removes one by one the letters of the given word from the scrambled string until
   no letters remain on one of scrambled string or the word
   
   Returns a vector of two values. The first is the remainand of the scrambled-string and
   the second is the remainand of the word"
  [scrambled-string word]
  (cond
    (or (= (count scrambled-string) 0)  (= (count word) 0)) [scrambled-string word]
    :else (recur (replace-first scrambled-string (first word) "") (rest word))))

(defn scrambled?
  "Checks whether a string [word] can be generated by scrambling a subset of another [scrambled-string]
   Returns true if the word can be produced by the scrambled string"
  [scrambled-string word]
  (= (- (count scrambled-string) (count word)) (count (first (replacer scrambled-string word)))))

(compojure.core/defroutes app-routes
  (compojure.core/GET "/scrambler" {params :params} [] {:status 200
                                                        :headers {"Access-Control-Allow-Origin" "*" "Content-Type" "application/json; charset=utf-8"}
                                                        :body (json/write-str {:result (scrambled? (get params :scrambled-string) (get params :word))})})

  (route/not-found "Not Found"))

(defn -main
  [& args]

  (run-jetty (handler/site app-routes) {:port 1337}))

